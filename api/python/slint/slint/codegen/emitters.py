from __future__ import annotations

import os
from pathlib import Path

import libcst as cst

from .models import GenerationConfig, ModuleArtifacts, CallbackMeta
from .utils import normalize_identifier, path_literal


def module_relative_path_expr(module_dir: Path, target: Path) -> str:
    try:
        rel = os.path.relpath(target, module_dir)
    except ValueError:
        return f"Path({path_literal(target)})"

    if rel in (".", ""):
        return "_MODULE_DIR"

    parts = Path(rel).parts
    expr = "_MODULE_DIR"
    for part in parts:
        if part == ".":
            continue
        expr += f" / {repr(part)}"
    return expr


def write_python_module(
    path: Path,
    *,
    source_relative: str,
    resource_name: str,
    config: GenerationConfig,
    artifacts: ModuleArtifacts,
) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    module_dir = path.parent

    include_exprs = [
        module_relative_path_expr(module_dir, include_path)
        for include_path in config.include_paths
    ]
    include_expr_code = f"[{', '.join(include_exprs)}]" if include_exprs else "None"

    library_items = [
        f"{path_literal(name)}: {module_relative_path_expr(module_dir, lib_path)}"
        for name, lib_path in config.library_paths.items()
    ]
    library_expr_code = f"{{{', '.join(library_items)}}}" if library_items else "None"

    style_expr = path_literal(config.style) if config.style else "None"
    domain_expr = path_literal(config.translation_domain) if config.translation_domain else "None"

    export_bindings: dict[str, str] = {}
    for component in artifacts.components:
        export_bindings[component.name] = component.py_name
    for struct in artifacts.structs:
        export_bindings[struct.name] = struct.py_name
    for enum in artifacts.enums:
        export_bindings[enum.name] = enum.py_name

    export_items = list(export_bindings.values()) + [
        normalize_identifier(alias) for _, alias in artifacts.named_exports
    ]

    header: list[cst.CSTNode] = [
        cst.EmptyLine(comment=cst.Comment(f"# Generated by slint.codegen from {source_relative}"))
    ]

    body: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
        _stmt("import importlib.resources as _resources"),
        _stmt("import os"),
        _stmt("import types"),
        _stmt("from contextlib import nullcontext as _nullcontext"),
        _stmt("from pathlib import Path"),
        _stmt("from typing import Any"),
        cst.EmptyLine(),
        _stmt("import slint"),
        cst.EmptyLine(),
    ]

    all_list = cst.List(
        elements=[cst.Element(cst.SimpleString(repr(item))) for item in export_items]
    )
    body.append(
        cst.SimpleStatementLine(
            [cst.Assign(targets=[cst.AssignTarget(cst.Name("__all__"))], value=all_list)]
        )
    )
    body.append(cst.EmptyLine())

    body.append(_stmt("_MODULE_DIR = Path(__file__).parent"))
    body.append(cst.EmptyLine())

    body.append(
        cst.SimpleStatementLine(
            [
                cst.Assign(
                    targets=[cst.AssignTarget(cst.Name("_SLINT_RESOURCE"))],
                    value=cst.SimpleString(repr(resource_name)),
                )
            ]
        )
    )
    body.append(cst.EmptyLine())

    load_source = (
        "def _load() -> types.SimpleNamespace:\n"
        "    \"\"\"Load the compiled Slint module for this package.\"\"\"\n"
        "    package = __package__ or (__spec__.parent if __spec__ else None)\n"
        "    if package:\n"
        "        ctx = _resources.as_file(_resources.files(package).joinpath(_SLINT_RESOURCE))\n"
        "    else:\n"
        "        ctx = _nullcontext(Path(__file__).with_name(_SLINT_RESOURCE))\n"
        "    with ctx as slint_path:\n"
        f"        include_paths: list[os.PathLike[Any] | Path] = {include_expr_code}\n"
        f"        library_paths: dict[str, os.PathLike[Any] | Path] | None = {library_expr_code}\n"
        "        return slint.load_file(\n"
        "            path=slint_path,\n"
        "            quiet=True,\n"
        f"            style={style_expr},\n"
        "            include_paths=include_paths,\n"
        "            library_paths=library_paths,\n"
        f"            translation_domain={domain_expr},\n"
        "        )\n"
    )

    load_func = cst.parse_module(load_source).body[0]

    body.append(load_func)
    body.append(cst.EmptyLine())
    body.append(_stmt("_module = _load()"))
    body.append(cst.EmptyLine())

    for original, binding in export_bindings.items():
        body.append(_stmt(f"{binding} = _module.{original}"))
    for orig, alias in artifacts.named_exports:
        alias_name = normalize_identifier(alias)
        target = export_bindings.get(orig, normalize_identifier(orig))
        body.append(_stmt(f"{alias_name} = {target}"))

    module = cst.Module(body=header + body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def write_stub_module(path: Path, *, artifacts: ModuleArtifacts) -> None:
    def _stmt(code: str) -> cst.BaseStatement:
        return cst.parse_statement(code)

    typing_imports = {"Any", "Callable"}

    def register_type(type_str: str) -> None:
        if "Optional[" in type_str:
            typing_imports.add("Optional")
        if "Literal[" in type_str:
            typing_imports.add("Literal")
        if "Union[" in type_str:
            typing_imports.add("Union")

    preamble: list[cst.CSTNode] = [
        _stmt("from __future__ import annotations"),
        cst.EmptyLine(),
        _stmt("import enum"),
        cst.EmptyLine(),
    ]

    post_body: list[cst.CSTNode] = []

    export_names = [component.py_name for component in artifacts.components]
    export_names += [struct.py_name for struct in artifacts.structs]
    export_names += [enum.py_name for enum in artifacts.enums]
    export_names += [
        normalize_identifier(alias) for _, alias in artifacts.named_exports
    ]
    if export_names:
        all_list = cst.List(
            elements=[cst.Element(cst.SimpleString(repr(name))) for name in export_names]
        )
        post_body.append(
            cst.SimpleStatementLine(
                [cst.Assign(targets=[cst.AssignTarget(cst.Name("__all__"))], value=all_list)]
            )
        )
        post_body.append(cst.EmptyLine())

    def ann_assign(name: str, type_expr: str) -> cst.BaseStatement:
        return cst.SimpleStatementLine(
            [
                cst.AnnAssign(
                    target=cst.Name(name),
                    annotation=cst.Annotation(annotation=cst.parse_expression(type_expr)),
                    value=None,
                )
            ]
        )

    def ellipsis_line() -> cst.BaseStatement:
        return cst.SimpleStatementLine([cst.Expr(value=cst.Ellipsis())])

    def init_stub() -> cst.FunctionDef:
        return cst.FunctionDef(
            name=cst.Name("__init__"),
            params=cst.Parameters(
                params=[cst.Param(name=cst.Name("self"))],
                star_kwarg=cst.Param(
                    name=cst.Name("kwargs"),
                    annotation=cst.Annotation(annotation=cst.Name("Any")),
                ),
            ),
            returns=cst.Annotation(annotation=cst.Name("None")),
            body=cst.IndentedBlock(body=[ellipsis_line()]),
        )

    for struct in artifacts.structs:
        struct_body: list[cst.BaseStatement] = [init_stub()]
        if struct.fields:
            for field in struct.fields:
                register_type(field.type_hint)
                struct_body.append(ann_assign(field.py_name, field.type_hint))
        else:
            struct_body.append(ellipsis_line())
        post_body.append(
            cst.ClassDef(
                name=cst.Name(struct.py_name),
                bases=[],
                body=cst.IndentedBlock(body=struct_body),
            )
        )
        post_body.append(cst.EmptyLine())

    for enum_meta in artifacts.enums:
        enum_body: list[cst.BaseStatement] = []
        if enum_meta.values:
            for value in enum_meta.values:
                enum_body.append(
                    cst.SimpleStatementLine(
                        [
                            cst.Assign(
                                targets=[cst.AssignTarget(cst.Name(value.py_name))],
                                value=cst.SimpleString(repr(value.value)),
                            )
                        ]
                    )
                )
        else:
            enum_body.append(ellipsis_line())
        post_body.append(
            cst.ClassDef(
                name=cst.Name(enum_meta.py_name),
                bases=[cst.Arg(value=cst.Attribute(value=cst.Name("enum"), attr=cst.Name("Enum")))],
                body=cst.IndentedBlock(body=enum_body),
            )
        )
        post_body.append(cst.EmptyLine())

    for component in artifacts.components:
        component_body: list[cst.BaseStatement] = [init_stub()]
        for prop in component.properties:
            register_type(prop.type_hint)
            component_body.append(ann_assign(prop.py_name, prop.type_hint))
        for callback in component.callbacks:
            annotation = format_callable_annotation(callback)
            register_type(annotation)
            component_body.append(ann_assign(callback.py_name, annotation))
        for fn in component.functions:
            annotation = format_callable_annotation(fn)
            register_type(annotation)
            component_body.append(ann_assign(fn.py_name, annotation))
        for global_meta in component.globals:
            component_body.append(
                ann_assign(global_meta.py_name, f"{component.py_name}.{global_meta.py_name}")
            )

        for global_meta in component.globals:
            inner_body: list[cst.BaseStatement] = []
            if not (global_meta.properties or global_meta.callbacks or global_meta.functions):
                inner_body.append(ellipsis_line())
            else:
                for prop in global_meta.properties:
                    register_type(prop.type_hint)
                    inner_body.append(ann_assign(prop.py_name, prop.type_hint))
                for callback in global_meta.callbacks:
                    annotation = format_callable_annotation(callback)
                    register_type(annotation)
                    inner_body.append(ann_assign(callback.py_name, annotation))
                for fn in global_meta.functions:
                    annotation = format_callable_annotation(fn)
                    register_type(annotation)
                    inner_body.append(ann_assign(fn.py_name, annotation))
            component_body.append(
                cst.ClassDef(
                    name=cst.Name(global_meta.py_name),
                    bases=[],
                    body=cst.IndentedBlock(body=inner_body),
                )
            )

        post_body.append(
            cst.ClassDef(
                name=cst.Name(component.py_name),
                bases=[
                    cst.Arg(
                        value=cst.Attribute(value=cst.Name("slint"), attr=cst.Name("Component"))
                    )
                ],
                body=cst.IndentedBlock(body=component_body),
            )
        )
        post_body.append(cst.EmptyLine())

    bindings: dict[str, str] = {}
    for component in artifacts.components:
        bindings[component.name] = component.py_name
    for struct in artifacts.structs:
        bindings[struct.name] = struct.py_name
    for enum_meta in artifacts.enums:
        bindings[enum_meta.name] = enum_meta.py_name

    for orig, alias in artifacts.named_exports:
        alias_name = normalize_identifier(alias)
        target = bindings.get(orig, normalize_identifier(orig))
        post_body.append(_stmt(f"{alias_name} = {target}"))
        post_body.append(cst.EmptyLine())

    typing_alias = ", ".join(sorted(typing_imports))
    preamble.append(_stmt(f"from typing import {typing_alias}"))
    preamble.append(cst.EmptyLine())
    preamble.append(_stmt("import slint"))
    preamble.append(cst.EmptyLine())

    body = preamble + post_body

    module = cst.Module(body=body)  # type: ignore[arg-type]
    path.write_text(module.code, encoding="utf-8")


def format_callable_annotation(callback: "CallbackMeta") -> str:  # type: ignore[name-defined]
    args = callback.arg_types
    return_type = callback.return_type

    args_literal = ", ".join(args)
    arg_repr = f"[{args_literal}]" if args_literal else "[]"
    return f"Callable[{arg_repr}, {return_type}]"


__all__ = [
    "module_relative_path_expr",
    "write_python_module",
    "write_stub_module",
]
